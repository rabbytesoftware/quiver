# Project Rules for Quiver

## Project Overview
Quiver is a **multi-platform, multi-paradigm package manager** following **Clean Architecture** principles. This is a Go-based project with a Terminal UI (Bubble Tea), REST API (Gin), and comprehensive testing requirements.

## Build and Compilation
- This project MUST be compiled using the Makefile
- Use `make build` for building the project
- Use `make run` for running the project
- Use `make test` for running tests
- Use `make test-coverage` for coverage reports
- Use `make pr-checks` for full PR validation
- Do NOT suggest alternative build methods - always refer to the Makefile

## Architecture and Design Patterns

### Clean Architecture Compliance
- **Dependencies point inward**: API → Usecases → Repositories → Infrastructure
- **Business logic in usecases**: Keep domain logic separate from technical concerns
- **Interface segregation**: Small, focused interfaces
- **Dependency injection**: All dependencies injected through constructors in `internal/internal.go`

### Layer Responsibilities
- **API Layer** (`/internal/api/`): HTTP REST API endpoints and middleware
- **Use Cases Layer** (`/internal/usecases/`): Business logic and application rules
- **Repository Layer** (`/internal/repositories/`): Data access abstraction
- **Infrastructure Layer** (`/internal/infrastructure/`): External concerns and technical implementation
- **Models Layer** (`/internal/models/`): Domain entities and business objects
- **Core Layer** (`/internal/core/`): Application core services (config, logging, metadata)

### Dependency Injection Container
- All dependencies are centralized in `internal/internal.go`
- Use constructor injection pattern
- Follow the established dependency graph:
  ```go
  Core → Infrastructure → Repositories → Usecases → API
  ```

## Code Organization and Structure

### File Size Guidelines
- **Maximum file size**: 500 lines
- **If larger**: Split into multiple files within the same package
- **Consider**: Breaking into separate packages if functionality grows significantly

### Package Organization
- Follow Go project layout standards:
  - `cmd/` for main applications
  - `internal/` for private application code
  - `docs/` for all documentation
- Keep related functionality together in the same package
- Use descriptive package names that describe functionality

### Import Organization
```go
// Standard library imports
import (
    "context"
    "fmt"
    "time"
)

// Third-party imports
import (
    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
)

// Internal imports
import (
    "github.com/rabbytesoftware/quiver/internal/models"
    "github.com/rabbytesoftware/quiver/internal/repositories"
)
```

## Go-Specific Best Practices

### Naming Conventions
- **Packages**: lowercase, single word (e.g., `models`, `api`)
- **Functions**: camelCase for private, PascalCase for public
- **Variables**: camelCase for private, PascalCase for public
- **Constants**: PascalCase or UPPER_CASE
- **Interfaces**: PascalCase, often ending with "er" (e.g., `Reader`, `Writer`)

### Error Handling
```go
// Always handle errors appropriately
result, err := someOperation()
if err != nil {
    return fmt.Errorf("operation failed: %w", err)
}

// Use wrapped errors for context
if err != nil {
    return fmt.Errorf("failed to create arrow %s: %w", arrowName, err)
}
```

### Context Usage
- Use `context.Context` for cancelable operations
- Pass context as the first parameter
- Handle context cancellation appropriately

### Interface Design
- Keep interfaces small and focused
- Use descriptive interface names
- Follow the interface segregation principle

## Testing Requirements

### Coverage Requirements
- **Overall Project Coverage**: ≥ 80%
- **Pull Request Coverage**: ≥ 90%
- All new code must have corresponding tests

### Test Structure
- Co-locate test files with source files (`*_test.go`)
- Use descriptive test names:
  ```go
  func TestNewArrow(t *testing.T)                    // Constructor tests
  func TestArrow_Create(t *testing.T)               // Method tests
  func TestArrow_WithInvalidInput(t *testing.T)     // Error case tests
  func TestArrow_Integration(t *testing.T)          // Integration tests
  ```

### Test Organization
- **Unit Tests**: Test individual components
- **Integration Tests**: Test component interactions
- **System Tests**: End-to-end functionality testing
- Use Docker for testing (`make test-docker`) to match CI environment

### Test Examples
```go
func TestCreateArrow(t *testing.T) {
    // Arrange
    name := "test-arrow"
    version := "1.0.0"
    
    // Act
    arrow, err := CreateArrow(name, version)
    
    // Assert
    if err != nil {
        t.Fatalf("Expected no error, got %v", err)
    }
    
    if arrow.Name != name {
        t.Errorf("Expected name %s, got %s", name, arrow.Name)
    }
}
```

## Git Workflow and Branching

### Branch Types and Rules
- **feature/*** → `develop` only
- **enhancement/*** → `develop` only  
- **fix/*** → `develop` only
- **hotfix/*** → `master` only
- **release/*** → `master` only (must originate from `develop`)

### Branch Naming Examples
- `feature/user-authentication`
- `enhancement/api-performance`
- `fix/memory-leak-issue`
- `hotfix/security-vulnerability`
- `release/2024-01-15`

### Commit Message Format
```
<type>(<scope>): <description>

[optional body]

[optional footer]
```

**Types**: feat, fix, docs, style, refactor, test, chore

**Examples**:
- `feat(api): add arrow search endpoint`
- `fix(ui): resolve memory leak in TUI model`
- `docs(readme): update installation instructions`

## API Development Guidelines

### REST API Standards
- **Base URL**: `http://localhost:40257/api/v1`
- **Content-Type**: `application/json`
- Use Gin framework for HTTP handling
- Follow RESTful conventions

### Endpoint Structure
```
/api/v1/
├── /health          # Health check
├── /arrow/          # Arrow management
│   ├── /search      # Search arrows
│   ├── /install     # Install arrow
│   └── /update      # Update arrow
├── /quiver/         # Quiver management
│   ├── /list        # List quivers
│   ├── /create      # Create quiver
│   └── /start       # Start quiver
└── /system/         # System operations
    ├── /status      # System status
    └── /info        # System information
```

### Error Handling
- Use consistent error response format
- Include error codes, messages, and details
- Handle validation errors appropriately
- Log errors at appropriate levels

## Documentation Standards

### Documentation Location
- **ALL markdown documentation files MUST go in the `./docs/` folder**
- Do NOT create markdown files in the root directory
- Use clear, descriptive filenames for documentation
- Update existing documentation rather than creating duplicates

### Code Documentation
```go
// Package models provides domain entities for the Quiver system.
package models

// Arrow represents a game server package that can be installed and run.
// It contains all necessary information for package management including
// metadata, requirements, dependencies, and execution methods.
type Arrow struct {
    // ID is the unique identifier for this arrow
    ID uuid.UUID `json:"id"`
    
    // Name is the human-readable name of the arrow
    Name string `json:"name"`
}
```

### Function Documentation
```go
// CreateArrow creates a new arrow with the specified name and version.
// It validates the input parameters and returns an error if validation fails.
// The created arrow will have a generated UUID and default configuration.
func CreateArrow(name, version string) (*Arrow, error) {
    // Implementation
}
```

## Domain Models and Business Logic

### Core Entities
- **Arrow**: Game server package entity
- **Quiver**: Repository where packages are found
- **Port**: Network port management
- **Variable**: Configuration variables
- **Requirement**: System requirements

### Model Validation
- Implement `IsValid()` methods for all domain models
- Validate business rules in domain layer
- Use appropriate error types for different validation failures

### Model Relationships
- Arrow dependencies must be resolved correctly
- Port allocation must handle conflicts
- Security levels must be enforced
- Variable types must be validated

## Terminal UI (TUI) Guidelines

### Bubble Tea Framework
- Follow Model-View-Update (MVU) pattern
- Use event-driven architecture
- Implement proper command parsing
- Handle user input gracefully

### TUI Components
- **Model**: Application state and logic
- **View**: Rendering and display
- **Update**: State transitions
- **Commands**: Side effects and async operations

## Configuration Management

### Configuration Files
- Use YAML for configuration (`internal/core/config/default.yaml`)
- Support environment variable overrides
- Follow the established configuration structure
- Document configuration changes in `./docs/`

### Environment Variables
- Use `QUIVER_` prefix for environment variables
- Support common overrides (port, log level, database path)
- Document all configuration options

## Security and Performance

### Security Guidelines
- Validate all inputs
- Use appropriate security levels (trusted/untrusted)
- Handle sensitive data appropriately
- Follow secure coding practices

### Performance Considerations
- Use connection pooling for database and HTTP connections
- Implement caching at repository level
- Use async operations where appropriate
- Monitor resource usage (CPU, memory, disk)

## Quality Assurance

### Code Quality Tools
- Use `golangci-lint` for comprehensive linting
- Use `gosec` for security vulnerability scanning
- Run `make pr-checks` before creating pull requests
- Follow Go conventions and best practices

### Pre-PR Checklist
- [ ] Code follows project style guidelines
- [ ] All tests pass (`make test`)
- [ ] Coverage requirements met (`make test-coverage`)
- [ ] Linting passes (`make lint`)
- [ ] Security checks pass (`make security`)
- [ ] Documentation updated if needed
- [ ] No breaking changes (or documented if necessary)

## Development Workflow

### Daily Development
```bash
# Run the application
make run

# Run tests during development
make test

# Check coverage
make test-coverage

# Format code
make fmt

# Run linting
make lint
```

### Before Creating PRs
```bash
# Run all PR validation checks
make pr-checks

# Validate branch naming
make validate-branch
```

## Technology Stack

### Core Technologies
- **Language**: Go 1.24.2
- **Web Framework**: Gin
- **Terminal UI**: Bubble Tea
- **Styling**: Lip Gloss
- **Logging**: Logrus
- **Configuration**: YAML
- **Testing**: Go testing + Docker
- **CI/CD**: GitHub Actions
- **Containerization**: Docker

### Development Tools
- **Build System**: Make
- **Code Quality**: golangci-lint
- **Security**: gosec
- **Containerization**: Docker

## File and Directory Management

### Directory Structure
- Respect the existing project structure
- Create new directories only when necessary for logical separation
- Use descriptive names for files and directories
- Keep related functionality together in the same package

### Generated Files
- `/bin/` - Compiled binaries
- `/logs/` - Application logs
- `coverage.out` - Test coverage reports
- `coverage.html` - HTML coverage reports

## Dependencies and Modules

### Dependency Management
- Use `go.mod` for dependency management
- Keep dependencies minimal and well-justified
- Update `go.sum` when adding/removing dependencies
- Follow semantic versioning for dependencies

### Import Guidelines
- Group imports: standard library, third-party, internal
- Use absolute imports for internal packages
- Avoid circular dependencies
- Keep import lists clean and organized

## Error Handling and Logging

### Error Types
- **Domain Errors**: Business rule violations
- **Infrastructure Errors**: Technical failures
- **Validation Errors**: Input validation failures
- **System Errors**: Unexpected failures

### Logging Standards
- Use structured logging with appropriate levels
- Log errors with sufficient context
- Use the Watcher service for centralized logging
- Follow the established log level hierarchy

## Testing Workflow Integration

### Testing Process
1. **Develop until milestone** - Complete features before testing
2. **Internal testing** - Unit, integration, system, manual, performance, security
3. **External testing** - 4-6 external testers with fresh perspectives
4. **Evaluate feedback** - Determine if build is "good enough"
5. **Iterate if needed** - Loop back to development if issues found

### Quality Gates
- All automated tests must pass
- Code coverage requirements met
- Performance benchmarks satisfied
- Security scans clean
- Manual testing completed

## Release Process

### Version Numbering
- Follow Semantic Versioning (MAJOR.MINOR.PATCH)
- Update version numbers in relevant files
- Update changelog with new features and fixes
- Create release notes for users

### Release Checklist
- [ ] Update version numbers
- [ ] Update changelog
- [ ] Run full test suite
- [ ] Update documentation
- [ ] Create release notes

## Best Practices Summary

### For All Development
- Follow Clean Architecture principles
- Write comprehensive tests
- Handle errors appropriately
- Use meaningful names
- Keep functions focused and single-purpose
- Document public APIs
- Update documentation when needed

### For API Development
- Follow RESTful conventions
- Use consistent error handling
- Implement proper validation
- Document all endpoints

### For TUI Development
- Follow MVU pattern
- Handle user input gracefully
- Implement proper event system
- Use appropriate styling

### For Testing
- Write tests alongside code
- Aim for high test coverage
- Use descriptive test names
- Test both success and error cases
- Use Docker for consistent testing environment

---

*This comprehensive ruleset ensures consistent, high-quality development following Clean Architecture principles, comprehensive testing, and proper Git workflow practices.*